import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { GridRenderer, paperTheme, highContrastTheme } from '../components/GridRenderer';
import { EventBus } from '../event-bus';
import type { Grid, GridCell, GridCoordinate, GameAnnotation } from '@gpg/shared';

// Helper function to create a test grid
const createTestGrid = (width: number, height: number): Grid => {
  const cells: GridCell[][] = [];
  
  for (let y = 0; y < height; y++) {
    const row: GridCell[] = [];
    for (let x = 0; x < width; x++) {
      row.push({
        coordinate: { x, y },
        state: 'empty',
        owner: undefined,
        metadata: {},
      });
    }
    cells.push(row);
  }
  
  return {
    width,
    height,
    cells,
    type: 'square',
  };
};

// Helper function to create a grid with some occupied cells
const createTestGridWithMoves = (): Grid => {
  const grid = createTestGrid(3, 3);
  
  // Make some cells occupied
  (grid.cells[0][0] as any) = { ...grid.cells[0][0], state: 'occupied', owner: 'player1' };
  (grid.cells[1][1] as any) = { ...grid.cells[1][1], state: 'highlighted' };
  (grid.cells[2][2] as any) = { ...grid.cells[2][2], state: 'disabled' };
  
  return grid;
};

// Helper function to create test annotations
const createTestAnnotations = (): GameAnnotation[] => [
  {
    type: 'highlight',
    coordinates: [{ x: 0, y: 0 }, { x: 1, y: 1 }],
    color: '#ff0000',
  },
  {
    type: 'text',
    coordinates: [{ x: 2, y: 2 }],
    text: 'Win!',
    color: '#00ff00',
  },
];

describe('GridRenderer', () => {
  let mockCanvas: any;
  let mockContext: any;
  
  beforeEach(() => {
    // Reset mock context for each test
    mockContext = {
      clearRect: vi.fn(),
      fillRect: vi.fn(),
      strokeRect: vi.fn(),
      beginPath: vi.fn(),
      moveTo: vi.fn(),
      lineTo: vi.fn(),
      stroke: vi.fn(),
      fill: vi.fn(),
      save: vi.fn(),
      restore: vi.fn(),
      scale: vi.fn(),
      fillText: vi.fn(),
      strokeText: vi.fn(),
      measureText: vi.fn(() => ({ width: 50 })),
      roundRect: vi.fn(),
      set fillStyle(value) { this._fillStyle = value; },
      get fillStyle() { return this._fillStyle; },
      set strokeStyle(value) { this._strokeStyle = value; },
      get strokeStyle() { return this._strokeStyle; },
      set lineWidth(value) { this._lineWidth = value; },
      get lineWidth() { return this._lineWidth; },
      set font(value) { this._font = value; },
      get font() { return this._font; },
      set textAlign(value) { this._textAlign = value; },
      get textAlign() { return this._textAlign; },
      set textBaseline(value) { this._textBaseline = value; },
      get textBaseline() { return this._textBaseline; },
      set globalAlpha(value) { this._globalAlpha = value; },
      get globalAlpha() { return this._globalAlpha; },
    };

    mockCanvas = {
      getContext: vi.fn(() => mockContext),
      getBoundingClientRect: vi.fn(() => ({
        left: 0,
        top: 0,
        right: 300,
        bottom: 300,
        width: 300,
        height: 300,
      })),
    };

    // Mock canvas creation
    const originalCreateElement = document.createElement.bind(document);
    vi.spyOn(document, 'createElement').mockImplementation((tagName) => {
      if (tagName === 'canvas') {
        return mockCanvas as any;
      }
      return originalCreateElement(tagName);
    });
  });

  afterEach(() => {
    EventBus.clear();
    vi.restoreAllMocks();
  });

  describe('Basic rendering', () => {
    it('should render a canvas element', () => {
      const grid = createTestGrid(3, 3);
      
      render(<GridRenderer grid={grid} />);
      
      const canvas = screen.getByRole('img', { hidden: true }) || document.querySelector('canvas');
      expect(canvas).toBeDefined();
    });

    it('should set correct canvas dimensions based on grid size and theme', () => {
      const grid = createTestGrid(3, 3);
      
      render(<GridRenderer grid={grid} theme={paperTheme} />);
      
      const canvas = document.querySelector('canvas');
      expect(canvas).toBeDefined();
      
      // Expected dimensions: (width * cellSize + padding * 2) = (3 * 32 + 2 * 2) = 100
      expect(canvas?.getAttribute('width')).toBe('100');
      expect(canvas?.getAttribute('height')).toBe('100');
    });

    it('should use custom width and height when provided', () => {
      const grid = createTestGrid(3, 3);
      
      render(<GridRenderer grid={grid} width={400} height={300} />);
      
      const canvas = document.querySelector('canvas');
      expect(canvas?.getAttribute('width')).toBe('400');
      expect(canvas?.getAttribute('height')).toBe('300');
    });

    it('should apply scaling to canvas dimensions', () => {
      const grid = createTestGrid(3, 3);
      
      render(<GridRenderer grid={grid} scale={2} />);
      
      const canvas = document.querySelector('canvas');
      // Dimensions should be doubled with scale=2
      expect(canvas?.getAttribute('width')).toBe('200'); // (3 * 32 + 4) * 2
      expect(canvas?.getAttribute('height')).toBe('200');
    });
  });

  describe('Grid rendering', () => {
    it('should clear canvas and apply scaling when rendering', () => {
      const grid = createTestGrid(2, 2);
      
      render(<GridRenderer grid={grid} scale={1.5} />);
      
      expect(mockContext.clearRect).toHaveBeenCalled();
      expect(mockContext.save).toHaveBeenCalled();
      expect(mockContext.scale).toHaveBeenCalledWith(1.5, 1.5);
      expect(mockContext.restore).toHaveBeenCalled();
    });

    it('should draw background with theme background color', () => {
      const grid = createTestGrid(2, 2);
      
      render(<GridRenderer grid={grid} theme={paperTheme} />);
      
      expect(mockContext.fillRect).toHaveBeenCalledWith(0, 0, expect.any(Number), expect.any(Number));
    });

    it('should draw grid lines based on grid dimensions', () => {
      const grid = createTestGrid(2, 2);
      
      render(<GridRenderer grid={grid} theme={paperTheme} />);
      
      // Should draw vertical and horizontal lines
      expect(mockContext.beginPath).toHaveBeenCalled();
      expect(mockContext.moveTo).toHaveBeenCalled();
      expect(mockContext.lineTo).toHaveBeenCalled();
      expect(mockContext.stroke).toHaveBeenCalled();
    });

    it('should render paper texture when enabled', () => {
      const grid = createTestGrid(2, 2);
      const theme = { ...paperTheme, paperTexture: true, paperColor: '#f0f0f0' };
      
      render(<GridRenderer grid={grid} theme={theme} />);
      
      // Should set global alpha for texture
      expect(mockContext).toHaveProperty('globalAlpha');
    });
  });

  describe('Cell rendering', () => {
    it('should render cells with different states', () => {
      const grid = createTestGridWithMoves();
      
      render(<GridRenderer grid={grid} />);
      
      // Should call fillRect for occupied cells (not transparent empty cells)
      expect(mockContext.fillRect).toHaveBeenCalled();
    });

    it('should render cell owner text when present', () => {
      const grid = createTestGridWithMoves();
      
      render(<GridRenderer grid={grid} />);
      
      // Should call fillText for cells with owners
      expect(mockContext.fillText).toHaveBeenCalled();
    });

    it('should use rounded rectangles when borderRadius > 0', () => {
      const grid = createTestGridWithMoves();
      const theme = { ...paperTheme, borderRadius: 5 };
      
      render(<GridRenderer grid={grid} theme={theme} />);
      
      // Should use roundRect instead of fillRect for cells
      expect(mockContext.roundRect).toHaveBeenCalled();
    });

    it('should use custom cell renderer when provided', () => {
      const grid = createTestGrid(2, 2);
      const customRenderer = vi.fn();
      
      render(<GridRenderer grid={grid} renderCell={customRenderer} />);
      
      // Custom renderer should be called for each cell
      expect(customRenderer).toHaveBeenCalledTimes(4); // 2x2 grid
    });
  });

  describe('Themes', () => {
    it('should use paperTheme as default', () => {
      const grid = createTestGrid(2, 2);
      
      render(<GridRenderer grid={grid} />);
      
      // Should use paper theme colors and settings
      const canvas = document.querySelector('canvas');
      expect(canvas).toBeDefined();
    });

    it('should apply highContrastTheme correctly', () => {
      const grid = createTestGrid(2, 2);
      
      render(<GridRenderer grid={grid} theme={highContrastTheme} />);
      
      // Should render without errors and use high contrast settings
      const canvas = document.querySelector('canvas');
      expect(canvas).toBeDefined();
    });

    it('should use custom theme properties', () => {
      const grid = createTestGrid(2, 2);
      const customTheme = {
        ...paperTheme,
        cellSize: 48,
        gridColor: '#ff0000',
        gridWidth: 3,
      };
      
      render(<GridRenderer grid={grid} theme={customTheme} />);
      
      const canvas = document.querySelector('canvas');
      // Canvas size should reflect custom cellSize
      expect(canvas?.getAttribute('width')).toBe('148'); // (2 * 48 + 4)
      expect(canvas?.getAttribute('height')).toBe('148');
    });
  });

  describe('Annotations', () => {
    it('should render highlight annotations', () => {
      const grid = createTestGrid(3, 3);
      const annotations = createTestAnnotations();
      
      render(<GridRenderer grid={grid} annotations={annotations} />);
      
      // Should draw stroke rectangles for highlights
      expect(mockContext.strokeRect).toHaveBeenCalled();
    });

    it('should render text annotations', () => {
      const grid = createTestGrid(3, 3);
      const annotations = createTestAnnotations();
      
      render(<GridRenderer grid={grid} annotations={annotations} />);
      
      // Should call fillText for text annotations
      expect(mockContext.fillText).toHaveBeenCalledWith('Win!', expect.any(Number), expect.any(Number));
    });

    it('should use annotation colors when provided', () => {
      const grid = createTestGrid(3, 3);
      const annotations: GameAnnotation[] = [
        {
          type: 'highlight',
          coordinates: [{ x: 0, y: 0 }],
          color: '#ff0000',
        },
      ];
      
      render(<GridRenderer grid={grid} annotations={annotations} />);
      
      // Should use custom annotation color
      expect(mockContext.strokeStyle).toBe('#ff0000');
    });
  });

  describe('Coordinate conversion', () => {
    it('should handle coordinate conversion correctly', async () => {
      const grid = createTestGrid(3, 3);
      const onCellClick = vi.fn();
      
      render(<GridRenderer grid={grid} onCellClick={onCellClick} />);
      
      const canvas = document.querySelector('canvas');
      expect(canvas).toBeDefined();
      
      if (canvas) {
        // Simulate click at position that should map to grid coordinate (1, 1)
        // With default theme: cellSize=32, padding=2, so cell (1,1) is at canvas (34, 34) to (66, 66)
        await userEvent.click(canvas, { clientX: 50, clientY: 50 });
        
        expect(onCellClick).toHaveBeenCalledWith(
          { x: 1, y: 1 },
          expect.objectContaining({ coordinate: { x: 1, y: 1 } })
        );
      }
    });

    it('should emit UI click events when interactive', async () => {
      const grid = createTestGrid(3, 3);
      const eventSpy = vi.fn();
      
      EventBus.subscribe('ui:click', eventSpy);
      
      render(<GridRenderer grid={grid} interactive={true} />);
      
      const canvas = document.querySelector('canvas');
      if (canvas) {
        await userEvent.click(canvas, { clientX: 50, clientY: 50 });
        
        expect(eventSpy).toHaveBeenCalled();
      }
    });

    it('should not handle clicks when non-interactive', async () => {
      const grid = createTestGrid(3, 3);
      const onCellClick = vi.fn();
      
      render(<GridRenderer grid={grid} interactive={false} onCellClick={onCellClick} />);
      
      const canvas = document.querySelector('canvas');
      if (canvas) {
        await userEvent.click(canvas, { clientX: 50, clientY: 50 });
        
        expect(onCellClick).not.toHaveBeenCalled();
      }
    });
  });

  describe('Mouse interactions', () => {
    it('should handle cell hover events', async () => {
      const grid = createTestGrid(3, 3);
      const onCellHover = vi.fn();
      
      render(<GridRenderer grid={grid} onCellHover={onCellHover} />);
      
      const canvas = document.querySelector('canvas');
      if (canvas) {
        await userEvent.hover(canvas, { clientX: 50, clientY: 50 });
        
        expect(onCellHover).toHaveBeenCalledWith(
          { x: 1, y: 1 },
          expect.objectContaining({ coordinate: { x: 1, y: 1 } })
        );
      }
    });

    it('should emit hover events when interactive', async () => {
      const grid = createTestGrid(3, 3);
      const eventSpy = vi.fn();
      
      EventBus.subscribe('ui:hover', eventSpy);
      
      render(<GridRenderer grid={grid} interactive={true} />);
      
      const canvas = document.querySelector('canvas');
      if (canvas) {
        await userEvent.hover(canvas, { clientX: 50, clientY: 50 });
        
        expect(eventSpy).toHaveBeenCalled();
      }
    });

    it('should handle mouse leave events', async () => {
      const grid = createTestGrid(3, 3);
      const onCellHover = vi.fn();
      
      render(<GridRenderer grid={grid} onCellHover={onCellHover} />);
      
      const canvas = document.querySelector('canvas');
      if (canvas) {
        // First hover over a cell
        await userEvent.hover(canvas, { clientX: 50, clientY: 50 });
        expect(onCellHover).toHaveBeenCalledWith(expect.any(Object), expect.any(Object));
        
        // Then mouse leave
        await userEvent.unhover(canvas);
        expect(onCellHover).toHaveBeenCalledWith(null, null);
      }
    });

    it('should only call hover handler when coordinate changes', async () => {
      const grid = createTestGrid(3, 3);
      const onCellHover = vi.fn();
      
      render(<GridRenderer grid={grid} onCellHover={onCellHover} />);
      
      const canvas = document.querySelector('canvas');
      if (canvas) {
        // Hover over same cell multiple times
        await userEvent.hover(canvas, { clientX: 50, clientY: 50 });
        await userEvent.hover(canvas, { clientX: 52, clientY: 52 }); // Still same cell
        
        // Should only call handler once since coordinate hasn't changed
        expect(onCellHover).toHaveBeenCalledTimes(1);
      }
    });
  });

  describe('Cursor styling', () => {
    it('should use pointer cursor when interactive', () => {
      const grid = createTestGrid(3, 3);
      
      render(<GridRenderer grid={grid} interactive={true} />);
      
      const canvas = document.querySelector('canvas');
      expect(canvas?.style.cursor).toBe('pointer');
    });

    it('should use default cursor when non-interactive', () => {
      const grid = createTestGrid(3, 3);
      
      render(<GridRenderer grid={grid} interactive={false} />);
      
      const canvas = document.querySelector('canvas');
      expect(canvas?.style.cursor).toBe('default');
    });
  });

  describe('Custom styling', () => {
    it('should apply custom className', () => {
      const grid = createTestGrid(3, 3);
      
      render(<GridRenderer grid={grid} className="custom-grid" />);
      
      const canvas = document.querySelector('canvas');
      expect(canvas?.className).toContain('custom-grid');
    });

    it('should apply custom styles', () => {
      const grid = createTestGrid(3, 3);
      const customStyle = { border: '2px solid red', borderRadius: '5px' };
      
      render(<GridRenderer grid={grid} style={customStyle} />);
      
      const canvas = document.querySelector('canvas');
      expect(canvas?.style.border).toBe('2px solid red');
      expect(canvas?.style.borderRadius).toBe('5px');
    });

    it('should preserve default imageRendering style', () => {
      const grid = createTestGrid(3, 3);
      
      render(<GridRenderer grid={grid} />);
      
      const canvas = document.querySelector('canvas');
      expect(canvas?.style.imageRendering).toBe('pixelated');
    });
  });

  describe('Edge cases', () => {
    it('should handle clicks outside grid boundaries', async () => {
      const grid = createTestGrid(3, 3);
      const onCellClick = vi.fn();
      
      render(<GridRenderer grid={grid} onCellClick={onCellClick} />);
      
      const canvas = document.querySelector('canvas');
      if (canvas) {
        // Click outside grid
        await userEvent.click(canvas, { clientX: 1000, clientY: 1000 });
        
        expect(onCellClick).not.toHaveBeenCalled();
      }
    });

    it('should handle empty grid', () => {
      const emptyGrid = createTestGrid(0, 0);
      
      expect(() => {
        render(<GridRenderer grid={emptyGrid} />);
      }).not.toThrow();
    });

    it('should handle grid with no annotations', () => {
      const grid = createTestGrid(2, 2);
      
      expect(() => {
        render(<GridRenderer grid={grid} annotations={[]} />);
      }).not.toThrow();
    });
  });
});